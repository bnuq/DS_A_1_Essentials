//Expected Time Complexity: O(n)

#include <bits/stdc++.h>
using namespace std;

/*
	인덱스 0 에서 부터 현재 인데스 i 사이에서, 현재 값이 최대 값인 구간이 어느정도 인가?
	i 인덱스 에서 0 을 향해서 조사 ~ 자신보다 큰 값이 처음으로 나오는 인덱스 j 를 찾는다 => i-j = 원하는 답
	그런데 각 인덱스 i 마다 0 을 향해 조사 => O(n^2) , 비효율적
	
	스택을 이용 => 스택 내에 값들을 정렬해서 넣는다? 임시 저장한다?
	
	0~i-1 구간에서 i-1 => 0 방향으로 바라보았을 때, 가려지지 않는 가장 작은 값이 스택의 top 에 저장되어 있다고 생각
	가려지지 않은 값들이 작은 것 -> 큰 것 순서대로 스택에 저장된다고 생각
	
	그러면 i 번째 값과 스택의 top 값을 비교했을 때, i 번째 값이 더 작으면 구간 값은 1 이고 그대로 스택에 추가
	스택의 top 값이 더 작으면 그 값은 이에 i 번째 값에 가려지니까 더이상 필요 없다 => pop 해서 버려버리고
	스택의 다음 top 값과 비교한다

	계속 반복해서 검색하지 않고, 한번 검사할 때 스택에 어떤 순서로 무엇을 저장할 것인가
*/
vector<int> stockSpanner(vector<int> &a){
	stack <int> s; // 스택에 인덱스를 저장한다
	int n = a.size();

	s.push(0); // 0번째 값은 혼자 있으니까 무조건 자기가 보여 => 무조건 추가
	vector<int> arr(n, 1); // 1 값이 기본 값

	// 주어진 벡터 값을 순서대로 조사
	for (int i = 1; i < n; i++) {
		// top 값이 현재 값보다 작다 => 현재 값에 가려진다
		while (!s.empty() and a[s.top()] <= a[i]) {
			s.pop();
		}

		// 현재 값보다 큰 top 값이 나왔다
		if (!s.empty()) {
			arr[i] = i - s.top();
		}
		// 스택이 비어버렸다 => 현재 값이 제일 컸다, 이전 값들을 모두 가려버렸다
		// 현재 값이 0번째 까지 모든 구간에서 최대값이다
		else arr[i] = i + 1;

		// 현재 값이, 옆에서 봤을 때 가려지지 않는 가장 작은 값이므로 스택에 추가한다
		s.push(i);
	}
	return arr;
}